%File: ~/OOP/analysis/integrator/DisplacementControl.tex
%What: "@(#) DisplacementControl.tex, revA"

\noindent {\bf Files}   \\
\indent \#include $<\tilde{ }$/analysis/integrator/DisplacementControl.h$>$  \\

UNDER CONSTRUCTION.\\

\noindent {\bf Class Declaration}  \\
\indent class DisplacementControl: public StaticIntegrator  \\

\noindent {\bf Class Hierarchy} \\
\indent MovableObject \\
\indent\indent Integrator \\
\indent\indent\indent IncrementalIntegrator \\
\indent\indent\indent\indent StaticIntegrator \\
\indent\indent\indent\indent\indent {\bf DisplacementControl} \\

\noindent {\bf Description} \\ 
\indent DisplacementControl is a subclass of StaticIntegrator, it is
used to when performing a static analysis on the FE\_Model using the
displacement control method. In the displacement control method the
displacement at a specified degree-of-freedom Uc is specified for each
iteration. The following constraint equation is added to
equation~\ref{staticFormTaylor} of the StaticIntegrator class: 

\[ 
Uc_n^{(i)} - Uc_{n-1} = \delta Uc_n
\]

\noindent where $\delta Uc_n$ depends on $\delta Uc_{n-1}$,
the displacement increment at the previous time step, $J_{n-1}$,
the number of iterations required to achieve convergence in the
previous load step, and $Jd$, the desired number of iteraions. $\delta
Uc_n$ is bounded by $\delta Uc_{min}$  and $\delta Uc_{max}$. \\


\[ 
\delta Ucn = max \left( \delta Uc{min}, min \left(
\frac{Jd}{J_{n-1}} \delta Uc{n-1}, \delta Uc{max} \right) \right)
\]

SOME THEORY.\\

\noindent {\bf Class Interface} \\
\indent // Constructors \\
\indent {\em DisplacementControl(int node, int dof, double $\delta Uc_1$, int Jd,  
double $\delta Uc_{min}$, double $\delta Uc_{max}$);}\\ \\
\indent // Destructor \\
\indent {\em $\tilde{ }$DisplacementControl();}\\  \\
\indent // Public Methods \\
\indent {\em int newStep(void);} \\
\indent {\em int update(const Vector \&$\Delta U$);} \\
\indent {\em int domainChanged(void);} \\ \\
\indent // Public Methods for Output\\
\indent {\em int sendSelf(int commitTag, Channel \&theChannel);}\\ 
\indent {\em int recvSelf(int commitTag, Channel \&theChannel,
FEM\_ObjectBroker \&theBroker);}\\ 
\indent {\em int Print(OPS_Stream \&s, int flag = 0);}\\

\noindent {\bf Constructors} \\
\indent {\em DisplacementControl(int node, int dof, double $\delta Uc_1$, int Jd,  
double $\delta Uc_{min}$, double $\delta Uc_{max}$);}\\ 
The integer INTEGRATOR\_TAGS\_DisplacementControl (defined in
$<$classTags.h$>$) is passed to the StaticIntegrator classes
constructor. $\delta Uc_1$ is the load factor used in the first
step. The arguments $Jd$, $\delta Uc_{min}$, and $\delta
Uc_{max}$ are used in the determination of the increment in the
load factor at each step. \\



\noindent {\bf Destructor} \\
\indent {\em $\tilde{ }$DisplacementControl();}\\ 
Does nothing. \\

\noindent {\bf Public Methods}\\

{\em int newStep(void);} \\
WHAT DO I DO?\\

{\em int update(const Vector \&$\Delta U$);} \\
WHAT DO I DO?\\

{\em int sendSelf(int commitTag, Channel \&theChannel); } \\ 
WHAT DO I DO?\\

{\em int recvSelf(int commitTag, Channel \&theChannel, 
FEM\_ObjectBroker \&theBroker); } \\ 
WHAT DO I DO?\\

{\em int Print(OPS_Stream \&s, int flag = 0);}\\
WHAT DO I DO?